/*****************************************************************************
*
* Copyright (c) 2000 - 2008, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-400142
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtSuntansFileFormat.h                           //
// ************************************************************************* //

#ifndef AVT_suntans_FILE_FORMAT_H
#define AVT_suntans_FILE_FORMAT_H

#include <avtMTMDFileFormat.h>

#include <vector>
#include <map>

using std::vector;

#define SUNTANS_MAX_PROCESSORS 1024

#include <vtkPoints.h>
#include <vtkUnstructuredGrid.h>
#include <vtkFloatArray.h>

// ****************************************************************************
//  Class: avtSuntansFileFormat
//
//  Purpose:
//      Reads in suntans files as a plugin to VisIt.
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Mon Oct 27 12:23:29 PDT 2008
//
// ****************************************************************************

class avtSuntansFileFormat;

typedef struct {
  double df,dg,n1,n2,xe,ye;
  int Nke,Nkc,grad1,grad2,gradf1,gradf2,mark,p1,p2;
} edgedata;

typedef struct {
  // xv        yv        Ac        dv        Nk Edge{1-3} Neigh{1-3} N{1-3}  def{1-3}
  // 18.987230 9.771761 235.743608 20.000000 40 0 1 2     3 145 -1   -1 1 -1 4.302172 6.518467 9.771761 
  double xv,yv,Ac,dv;
  int Nk,edges[3],neighs[3],norms[3];
  double defs[3];
  int ghost;
} celldata;

// raw_metadata: keep tabs on raw fields, where we don't know a priori what the format is
// could eventually be used to describe all of the variables, so keep it generic.
class LocalMetadata {
public:
  int has_time; 
  int has_cell;
  int has_edge;
  int has_z_level;
  int is_normal; // edge-centered data should be considered a vector normal to face.
  int n_components; // if the data, as stored, is scalar, 2-D vectors or 3-D vectors

  std::string filename; // without the .domain suffix
  std::string name; // just the final part of the name
  std::string visit_label; // how visit will reference this - 
  // in the case of face-normal values, the visit_label here refers to the scalar field,
  // but Add() will register both the scalar name and the vector name to a copy of this
  // LocalMetadata structure
  std::string visit_normal_label;

  // add ourselves to the metadata structure
  void Add(avtDatabaseMetaData *md);
};

class SunGrid {
public:
  int domain;
  avtSuntansFileFormat *parent;

  int n_3d_cells;
  // map 3D cell ids to real cells, because cells that are
  // underground are not output.
  std::map<int,int> full_cell2valid;

  int wet_cell_timestate;
  std::vector<int> wet_cell_index;

  // these should mirror the arrays in gridT
  int Nc;
  int Ne;
  int Ne_Nke;
  int Nc_Nk;

  
  std::vector<edgedata> edges; 
  std::vector<celldata> cells; 
  // std::vector<int> Nk; // z-levels per cell

  SunGrid(avtSuntansFileFormat *,int);

  void read_edgedata();
  void read_celldata();

  void initialize_wet_cells(int);
  vtkDataSet* ReadSurfaceMesh();
  vtkDataSet* ReadFull3DMesh();
  vtkDataSet* ReadFaceMesh();
  
  vtkDataArray *GetVarFreesurface(int);
  vtkDataArray *GetVarNk();

  vtkDataArray *GetVarCrashFreesurface();
  vtkDataArray *GetVarCrashSalinity();
  vtkDataArray *GetVarCrashNormVelocity();
  vtkDataArray *GetVarCrashNormWVelocity();
  vtkDataArray *GetVectorVarCrashVelocity();
  vtkDataArray *GetVectorVarCrashWVelocity();

  vtkDataArray *GetVarStoreFreesurface();
  vtkDataArray *GetVarStoreSalinity();
  vtkDataArray *GetVarStoreNormVelocity();
  vtkDataArray *GetVarStoreNormWVelocity();
  vtkDataArray *GetVectorVarStoreVelocity();
  vtkDataArray *GetVectorVarStoreWVelocity();

  vtkDataArray *GetVarStoreFreesurface(std::string);
  vtkDataArray *GetVarStoreNormVelocity(std::string);
  vtkDataArray *GetVarStoreNormWVelocity(std::string);
  vtkDataArray *GetVarStoreSalinity(std::string);

  vtkDataArray *GetVarBathymetry();
  vtkDataArray *GetVar3DScalar(int,const char *);
  vtkDataArray *GetVarSurfaceScalar(int, const char *);
  vtkDataArray *GetVarBedScalar(int , const char *);
  
  vtkDataArray *GetVectorVarVelocity(int);
  vtkDataArray *GetVectorVarVelocitySurface(int);
  vtkDataArray *GetVectorVarFaceNormals();
  vtkDataArray *GetVarRaw(int, const char *);
  vtkDataArray *GetVectorVarRaw(int, const char *);

  vtkDataArray *project_to_facenormal(vtkDataArray *);
  vtkDataArray *project_w_vectors(vtkDataArray *);

private:
  vtkUnstructuredGrid *surf_mesh,*full_mesh,*face_mesh;
  vtkFloatArray *bathymetry;
};

class avtSuntansFileFormat : public avtMTMDFileFormat
{
  public:
                       avtSuntansFileFormat(const char *);
    virtual           ~avtSuntansFileFormat() {;};

    //
    // This is used to return unconvention data -- ranging from material
    // information to information about block connectivity.
    //
    // virtual void      *GetAuxiliaryData(const char *var, int timestep, 
    //                                     int domain, const char *type, void *args, 
    //                                     DestructorFunction &);
    //

    //
    // If you know the times and cycle numbers, overload this function.
    // Otherwise, VisIt will make up some reasonable ones for you.
    //
    // virtual void        GetCycles(std::vector<int> &);
    // virtual void        GetTimes(std::vector<double> &);
    //

    virtual int            GetNTimesteps(void);
    virtual void           GetTimes(std::vector<double> &);
    virtual void           GetCycles(std::vector<int> &);
    
    virtual const char    *GetType(void)   { return "suntans"; };
    virtual void           FreeUpResources(void); 

    virtual vtkDataSet    *GetMesh(int, int, const char *);
    virtual vtkDataArray  *GetVar(int, int, const char *);
    virtual vtkDataArray  *GetVectorVar(int, int, const char *);

  // DATA MEMBERS
  
  virtual void           PopulateDatabaseMetaData(avtDatabaseMetaData *, int);
  
  std::string GetFilePath(std::string config_name);
  std::string GetFilePath(std::string config_name,int proc);

  SunGrid *subdomain(int);
  
  int available_timesteps;
  // the time, in days, of step 0
  // the reference is a bit fuzzy here - for now, it will count from the
  // 0th day in the year given in suntans.dat - note that this gets bad
  // when crossing between years in one simulation.
  double t0_days;
  // for restarts, this is the restart timestep - otherwise 0.
  // taken from start.dat.0
  int starting_timestep;

  int domain_count;

  int has_crash_file;

  std::vector<SunGrid*> domain_cache;

  int total_Nc; // surface
  int total_n_3d_cells;   // full 3D mesh cells
  int nkmax;
  double dzmin;

  /* profile stuff */
  int prof_total_points;
  int prof_numInterpPoints;
  int prof_NkmaxProfs;
  int prof_ntoutProfs;

  // just for the point-depth data, this is
  // all x,y,z:
  std::vector<float> depths;

  
  // values read from the suntans.dat file:
  std::map<std::string,std::string> settings;

  std::map<std::string,LocalMetadata> raw_vars;

  // sum over vertspace.dat
  vector<float> cell_divisions;

  // reads suntans.dat
  void ReadSuntansDat(ifstream &ifile);
  // reads steps.dat, to find out how far along the simulation is
  void ReadSteps(void);
  // look for cells.dat files to get a count of the number of processors
  void ReadDomainCount(void);
  
  vtkPoints *ReadPoints(void);

  // if a separate list of depth measurements is specified:
  vtkPoints *ReadDepthPoints(void);

  vtkDataSet *ReadPointDepthMesh();
  // vtkDataSet *ReadSurfaceMesh(int timestate,int domain);
  // vtkDataSet *ReadFull3DMesh(int timestate,int domain);
  vtkDataSet *ReadFaceMesh(int timestate,int domain);
  vtkDataSet *Read2DProfileMesh(void);

  void AddDynamicFiles(avtDatabaseMetaData *md);
  void FindCrashFile(void);

  // // stores indexes of top wet cell, for each domain at a given timestate
  // int wet_cell_timestate;
  // void initialize_wet_cells(int timestate,int domain);
private:
  vtkPoints *points;
};


#endif
