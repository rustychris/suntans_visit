/*****************************************************************************
*
* Copyright (c) 2000 - 2010, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtSuntansFileFormat.C                           //
// ************************************************************************* //

#include <avtSuntansFileFormat.h>

#include <string>
#include <algorithm>
#include <iosfwd>
#include <map>

#include <vtkFloatArray.h>
#include <vtkDoubleArray.h>
#include <vtkUnsignedCharArray.h>
#include <vtkUnstructuredGrid.h>
#include <vtkCellType.h>
#include <vtkCellData.h>
#include <vtkPoints.h>

#include <avtDatabaseMetaData.h>
#include <avtGhostData.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>

#include <StringHelpers.h>
// In Visit 2.0, ReadAndProcessDirectory has moved:
// #include <Utility.h>
#include <FileFunctions.h>


#include <DebugStream.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#if defined(_WIN32)
 #include <win32-regex.h>
#else
 #include <regex.h>
#endif


using     std::string;
using     std::vector;

#define EMPTY 999999 /* should match suntans.h */

#define MESH_3D "fullmesh"
#define MESH_2D "surface"
#define MESH_2D_PROF "surf_profile"
#define MESH_FACES "faces"
#define MESH_DEPTH "depth"

#define RAW "raw/"


// utility class for handling grid data
SunGrid::SunGrid(avtSuntansFileFormat *p,int d) {
  parent = p;
  domain = d;
  wet_cell_timestate = -1;
  surf_mesh = NULL;
  full_mesh = NULL;
  face_mesh = NULL;

  bathymetry = NULL;

  read_edgedata();
  read_celldata();
}


// ****************************************************************************
//  Method: avtSuntansFileFormat constructor
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Mon Oct 27 12:23:29 PDT 2008
//
// ****************************************************************************

avtSuntansFileFormat::avtSuntansFileFormat(const char *filename)
    : avtMTMDFileFormat(filename)
{
  points = NULL;
  
  // INITIALIZE DATA MEMBERS
  ifstream ifile(filename);

  debug1 << "SUNTANS: Opening " << filename << endl;
  if (ifile.fail()) {
    debug1 << "Unable to open file " << filename << endl;
  } else {
    ReadSuntansDat(ifile);
    ReadSteps();
    ReadDomainCount();
    FindCrashFile();
  }
  dzmin = 0.001;
}

void avtSuntansFileFormat::ReadSteps(void) {
  // more info...
  string step_filename = GetFilePath("progressfile");

  ifstream step_fp(step_filename.c_str());

  available_timesteps = 0;

  if ( !step_fp ) {
    debug1 << "Couldn't open step file - probably a failed run" << endl;
    return;
  }

  regex_t cre;
  regmatch_t pm[10];

  // example output:
  // On 5000 of 5000, t=49990.00 (100% Complete, 501 output)
  if ( regcomp(&cre, "^On ([0-9]+) of ([0-9]+), t=([0-9\\.]+) \\([0-9\\.]+% Complete, ([0-9]+) output\\)$",
               REG_EXTENDED)) {
    debug1 << "Couldn't compile pattern for reading step.dat" << endl;
    available_timesteps = 0;
    return;
  }

  string linebuff;
  getline(step_fp,linebuff);

  if ( regexec(&cre, linebuff.c_str(), 10, pm, 0) == 0 ) {
    if ( pm[4].rm_so >= 0 ) {
      available_timesteps = atoi( linebuff.c_str() + pm[4].rm_so );
    } else {
      debug1 << "Matched, but didn't get substring match!\n";
    }
  } else {
    debug1 << "Unable to read line from step file " << step_filename << endl;
    // fall back to reading the store output
    string store_filename = GetFilePath("storefile",0);
    ifstream store_fp(store_filename.c_str());

    if ( store_fp ) {
      // RCH: I'm sure there is a visit-compatible way of defining 32 bit integers, but
      // for the moment I think most 64-bit platforms still have int as 32 bits.
      int last_step=0;
      store_fp.read((char*)&last_step,sizeof(last_step));
      
      available_timesteps = 1 + (int) ( last_step / atoi(settings["ntout"].c_str()) );
      
      debug1 << "Got available timesteps " << available_timesteps << " from store.dat.0" << endl;
    }
  }

  // Read the starting timestep from start.dat
  string start_filename = GetFilePath("startfile",0);
  ifstream start_fp(start_filename.c_str());

  if ( !start_fp ) {
    starting_timestep = 0;
  } else {
    start_fp.read((char*)&starting_timestep,sizeof(starting_timestep));
    debug1 << "Got starting timestep " << starting_timestep << " from start.dat.0" << endl;
  }  

  // And get the date of time zero:
  if ( settings.find("start_day") != settings.end() ) {
    t0_days = atof( settings["start_day"].c_str());
  } else {
    t0_days = 0.0;
  }
}

void avtSuntansFileFormat::FindCrashFile(void) {
  has_crash_file = 0;

  // Is there a crash file (like store.dat.*, but named crash.dat.*)
  string crash_path = GetFilePath("CrashFile") + string(".0");

  struct stat statbuf;

  has_crash_file = stat(crash_path.c_str(),&statbuf) == 0;

  debug1 << "Checked for crash file: " << crash_path << " and found " << has_crash_file << endl;
}


void avtSuntansFileFormat::ReadDomainCount(void) {
  string cells_filename = GetFilePath("cells");
  struct stat statbuf;

  char *buff = new char[cells_filename.size()+10];

  for(int i=0;i<SUNTANS_MAX_PROCESSORS;i++) {
    sprintf(buff,"%s.%d",cells_filename.c_str(),i);

    if ( stat(buff,&statbuf) != 0 ) {
      domain_count = i;
      break;
    }
  }

  domain_cache.resize(domain_count,NULL);

  delete[] buff;
}

SunGrid *avtSuntansFileFormat::subdomain(int domain) {
  if( domain_cache[domain] == NULL ) {
    debug1 << "Allocating new SunGrid instance" << endl;
    domain_cache[domain] = new SunGrid(this,domain);
  }
  return domain_cache[domain];
}


// given the type of file, e.g. SalinityFile, return
// a path that can be used to open that file
std::string avtSuntansFileFormat::GetFilePath(std::string config_name) {
  string my_path = StringHelpers::Dirname(GetFilename());

  // special handling of CrashFile, since it doesn't get configured via
  // suntans.dat
  if ( config_name.compare("CrashFile")==0 )
    return my_path + "/crash.dat";
  else {
    std::transform(config_name.begin(), config_name.end(), config_name.begin(), ::tolower);
    return my_path + '/' + settings[config_name];
  }
}

std::string avtSuntansFileFormat::GetFilePath(std::string config_name,int proc)
{
  std::ostringstream extended;
  std::string base = GetFilePath(config_name);

  extended << base << "." << proc;
  return std::string(extended.str());
}

// Read global settings from the suntans file...
void avtSuntansFileFormat::ReadSuntansDat(ifstream &ifile)
{
  string linebuff;
  
  regex_t cre;
  regmatch_t pm[10];

  if ( regcomp(&cre, "^[[:blank:]]*([a-zA-Z_0-9]+)[[:blank:]]+([-a-zA-Z_0-9\\./]+).*$",
               REG_EXTENDED)) {
    debug1 << "Couldn't compile pattern for reading suntans file" << endl;
    return;
  }

  while( ifile.good() ) {
    getline(ifile,linebuff);

    if ( regexec(&cre, linebuff.c_str(), 10, pm, 0) == 0 ) {
      string keyval[2];
      keyval[0] = linebuff.substr(pm[1].rm_so,pm[1].rm_eo - pm[1].rm_so);
      keyval[1] = linebuff.substr(pm[2].rm_so,pm[2].rm_eo - pm[2].rm_so);
      //settings.push_back(keyval);

      std::transform(keyval[0].begin(), keyval[0].end(), keyval[0].begin(), ::tolower);
      debug1 << " Read setting: " << keyval[0] << " => " << keyval[1] << endl;
      settings[keyval[0]] = keyval[1];
    }
  }

  // some useful settings to pull out ahead of time:
  nkmax = atoi(settings["nkmax"].c_str());
  debug1 << "nkmax is " << nkmax << endl;

  // read the vertical cell spacing. note that this is the summed up, bottom
  // of cell elevations (i.e. negative)
  string vert_fname = GetFilePath("vertspace");
  debug1 << "vertspace file path: "<<vert_fname << endl;
  ifstream vert_fp(vert_fname.c_str());
  float cell_bottom=0.0,cell_height;
  cell_divisions.push_back(cell_bottom);
  for(int i=0;i<nkmax;i++) {
    vert_fp >> cell_height; 
    cell_bottom -= cell_height;
    cell_divisions.push_back(cell_bottom);
    debug1 << "Read cell bottom elevation: " << cell_bottom << endl;
  }
}


// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Mon Oct 27 12:23:29 PDT 2008
//
// ****************************************************************************

int
avtSuntansFileFormat::GetNTimesteps(void)
{
  if ( available_timesteps > 0 )
    return available_timesteps;
  else
    return 1; // just make up data...
}


// ****************************************************************************
//  Method: avtSuntansFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Mon Oct 27 12:23:29 PDT 2008
//
// ****************************************************************************

void
avtSuntansFileFormat::FreeUpResources(void)
{
}


// ****************************************************************************
//  Method: avtSuntansFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Mon Oct 27 12:23:29 PDT 2008
//
// ****************************************************************************


void
avtSuntansFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
  //
  // 2D GRID 
  //
  avtMeshMetaData *mmd_2d = new avtMeshMetaData;
  mmd_2d->name = MESH_2D;
  mmd_2d->spatialDimension = 2;
  mmd_2d->topologicalDimension = 2;
  mmd_2d->meshType = AVT_UNSTRUCTURED_MESH;
  mmd_2d->numBlocks = domain_count; 
  md->Add(mmd_2d);

  avtMeshMetaData *mmd_2dprof = new avtMeshMetaData;
  mmd_2dprof->name = MESH_2D_PROF;
  mmd_2dprof->spatialDimension = 2;
  mmd_2dprof->topologicalDimension = 0;
  mmd_2dprof->meshType = AVT_POINT_MESH;
  mmd_2dprof->numBlocks = 1; 
  md->Add(mmd_2dprof);
 
  avtScalarMetaData *smd;
  if ( available_timesteps > 0 ) {
    // freesurface (might need to actually check to make sure fs was output)
    smd = new avtScalarMetaData;
    smd->name = "freesurface";
    smd->meshName = mmd_2d->name; // "surface";
    smd->centering = AVT_ZONECENT;
    smd->hasUnits = true;
    smd->units = "meter";
    md->Add(smd);

    // Profile outputs of the freesurface:
    smd = new avtScalarMetaData;
    smd->name = "prof_freesurface";
    smd->meshName = mmd_2dprof->name;
    smd->hasUnits = true;
    smd->units = "meter";
    md->Add(smd);
  }

  smd = new avtScalarMetaData;
  smd->name = "Nk";
  smd->meshName = mmd_2d->name; // "surface";
  smd->centering = AVT_ZONECENT;
  smd->hasUnits = false;
  md->Add(smd);

  // freesurface at last restore file
  smd = new avtScalarMetaData;
  smd->name = "store/freesurface";
  smd->meshName = mmd_2d->name; //"surface";
  smd->centering = AVT_ZONECENT;
  smd->hasUnits = true;
  smd->units = "meter";
  md->Add(smd);


  // bathymetry
  smd = new avtScalarMetaData;
  smd->name = "bathymetry";
  smd->meshName = mmd_2d->name; //"surface";
  smd->centering = AVT_ZONECENT;
  smd->hasUnits = true;
  smd->units = "meter";
  md->Add(smd);

  avtVectorMetaData *vmd;
  if ( available_timesteps > 0 ) {
    // might need to check that velocity was actually output
    vmd = new avtVectorMetaData;
    vmd->name = "velocity_surface";
    vmd->meshName = mmd_2d->name; // "surface";
    vmd->centering = AVT_ZONECENT;
    vmd->hasUnits = true;
    vmd->varDim = 3; // seems like 2 here didn't really work
    vmd->units = "m/s";
    md->Add(vmd);
  }

  // Point grid for depth data, if present
  //
  struct stat statbuf;
  string depth_file = GetFilePath("depth");
  if ( stat(depth_file.c_str(),&statbuf) == 0 ) {
    avtMeshMetaData *mmd_depth = new avtMeshMetaData;
    mmd_depth->name = MESH_DEPTH;
    mmd_depth->spatialDimension = 2;
    mmd_depth->topologicalDimension = 0;
    mmd_depth->meshType = AVT_POINT_MESH;
    mmd_depth->numBlocks = 1; // depth data is not decomposed into subdomains
    md->Add(mmd_depth);
    
    smd = new avtScalarMetaData;
    smd->name = "point_depth";
    smd->meshName = MESH_DEPTH; 
    smd->hasUnits = true;
    smd->units = "meter";
    md->Add(smd);
  }

  // values defined throughout the depth cells
  // velocity, salinity, temperature
  avtMeshMetaData *mmd_3d = new avtMeshMetaData;
  mmd_3d->name = MESH_3D;
  mmd_3d->spatialDimension = 3;
  mmd_3d->topologicalDimension = 3;
  mmd_3d->meshType = AVT_UNSTRUCTURED_MESH;
  mmd_3d->numBlocks = domain_count;
  md->Add(mmd_3d);

  if ( available_timesteps > 0 ) {
    // might need to check that velocity was actually output
    vmd = new avtVectorMetaData;
    vmd->name = "velocity_3d";
    vmd->meshName = mmd_3d->name; // "fullmesh";
    vmd->centering = AVT_ZONECENT;
    vmd->hasUnits = true;
    vmd->varDim = 3;
    vmd->units = "m/s";
    md->Add(vmd);

    smd = new avtScalarMetaData;
    smd->name = "salinity";
    smd->meshName = mmd_3d->name; // fullmesh
    smd->centering = AVT_ZONECENT;
    smd->hasUnits = true;
    smd->units = "psu?";
    md->Add(smd);

    smd = new avtScalarMetaData;
    smd->name = "temperature";
    smd->meshName = mmd_3d->name; // fullmesh
    smd->centering = AVT_ZONECENT;
    smd->hasUnits = false;
    md->Add(smd);

    smd = new avtScalarMetaData;
    smd->name = "nu_t_vert";
    smd->meshName = mmd_3d->name; // fullmesh
    smd->centering = AVT_ZONECENT;
    smd->hasUnits = false;
    md->Add(smd);
    
    smd = new avtScalarMetaData;
    smd->name = "temperature_surface";
    smd->meshName = mmd_2d->name; // surface mesh
    smd->centering = AVT_ZONECENT;
    smd->hasUnits = false;
    md->Add(smd);

    smd = new avtScalarMetaData;
    smd->name = "salinity_surface";
    smd->meshName = mmd_2d->name; // surface mesh
    smd->centering = AVT_ZONECENT;
    smd->hasUnits = false;
    md->Add(smd);

    smd = new avtScalarMetaData;
    smd->name = "nu_t_vert_surface";
    smd->meshName = mmd_2d->name; // surface mesh
    smd->centering = AVT_ZONECENT;
    smd->hasUnits = false;
    md->Add(smd);

    // experimental bed fields:
    smd = new avtScalarMetaData;
    smd->name = "temperature_bed";
    smd->meshName = mmd_2d->name; // surface mesh
    smd->centering = AVT_ZONECENT;
    smd->hasUnits = false;
    md->Add(smd);

    smd = new avtScalarMetaData;
    smd->name = "salinity_bed";
    smd->meshName = mmd_2d->name; // surface mesh
    smd->centering = AVT_ZONECENT;
    smd->hasUnits = false;
    md->Add(smd);

    smd = new avtScalarMetaData;
    smd->name = "nu_t_vert_bed";
    smd->meshName = mmd_2d->name; // surface mesh
    smd->centering = AVT_ZONECENT;
    smd->hasUnits = false;
    md->Add(smd);
  }

  // restore files
  // should check first to see that a store file actually exists, but 
  // I don't feel like doing that right now.
  


  /* 3D face data: */
  avtMeshMetaData *mmd_faces = new avtMeshMetaData;
  mmd_faces->name = MESH_FACES;
  mmd_faces->spatialDimension = 3;
  mmd_faces->topologicalDimension = 1;
  mmd_faces->meshType = AVT_UNSTRUCTURED_MESH;
  mmd_faces->numBlocks = domain_count;
  md->Add(mmd_faces);


  // This one just puts a unit velocity on all faces 
  vmd = new avtVectorMetaData;
  vmd->name = "face_normals";
  vmd->meshName = mmd_faces->name; // "faces";
  vmd->centering = AVT_ZONECENT;
  vmd->hasUnits = false;
  vmd->varDim = 3;
  md->Add(vmd);

  if ( 1 ) { // store files
     // might need to check that a storefile actually exists
     smd = new avtScalarMetaData;
     smd->name ="store/norm_velocity";
     smd->meshName = mmd_faces->name;
     smd->centering = AVT_ZONECENT;
     smd->hasUnits = true;
     smd->units = "m/s";
     md->Add(smd);
     
     vmd = new avtVectorMetaData;
     vmd->name = "store/velocity";
     vmd->meshName = mmd_faces->name; // "faces";
     vmd->centering = AVT_ZONECENT;
     vmd->hasUnits = true;
     vmd->varDim = 3;
     vmd->units = "m/s";
     md->Add(vmd);
   
     // A bit of a lie - the w velocity vectors really reside
     // between z-levels, but I don't want to make a whole new
     // mesh.
     vmd = new avtVectorMetaData;
     vmd->name = "store/w_velocity";
     vmd->meshName = mmd_3d->name; // "fullmesh";
     vmd->centering = AVT_ZONECENT;
     vmd->hasUnits = true;
     vmd->varDim = 3;
     vmd->units = "m/s";
     md->Add(vmd);
   
     smd = new avtScalarMetaData;
     smd->name ="store/salinity";
     smd->meshName = mmd_3d->name;
     smd->centering = AVT_ZONECENT;
     smd->hasUnits = true;
     smd->units = "psu";
     md->Add(smd);
  }
   
  if ( has_crash_file ) {
    smd = new avtScalarMetaData;
    smd->name = "crash/freesurface";
    smd->meshName = mmd_2d->name; //"surface";
    smd->centering = AVT_ZONECENT;
    smd->hasUnits = true;
    smd->units = "meter";
    md->Add(smd);

    smd = new avtScalarMetaData;
    smd->name ="crash/norm_velocity";
    smd->meshName = mmd_faces->name;
    smd->centering = AVT_ZONECENT;
    smd->hasUnits = true;
    smd->units = "m/s";
    md->Add(smd);
    
    vmd = new avtVectorMetaData;
    vmd->name = "crash/velocity";
    vmd->meshName = mmd_faces->name; // "faces";
    vmd->centering = AVT_ZONECENT;
    vmd->hasUnits = true;
    vmd->varDim = 3;
    vmd->units = "m/s";
    md->Add(vmd);
    
    vmd = new avtVectorMetaData;
    vmd->name = "crash/w_velocity";
    vmd->meshName = mmd_3d->name; // "fullmesh";
    vmd->centering = AVT_ZONECENT;
    vmd->hasUnits = true;
    vmd->varDim = 3;
    vmd->units = "m/s";
    md->Add(vmd);
    
    smd = new avtScalarMetaData;
    smd->name ="crash/salinity";
    smd->meshName = mmd_3d->name;
    smd->centering = AVT_ZONECENT;
    smd->hasUnits = true;
    smd->units = "psu";
    md->Add(smd);
  } 
  
  // Dynamically add raw data files 
  AddDynamicFiles(md);

  // Expressions :
  Expression new_expr;
  new_expr.SetName("wc_height");
  new_expr.SetDefinition("freesurface - bathymetry");
  new_expr.SetType(Expression::ScalarMeshVar);
  md->AddExpression(&new_expr);
}


// Some machinery for reading directories the visit way...
void save_file_name(void *data, const std::string &filename, bool a, bool b, long c) {
  std::vector<std::string> *files;
  files = (std::vector<std::string>*)data;

  files->push_back(filename);
}

void avtSuntansFileFormat::AddDynamicFiles(avtDatabaseMetaData *md)
{
  string datadir = StringHelpers::Dirname(GetFilename());
  std::vector<std::string> filenames;
  regex_t cre;
  regmatch_t pm[10];
  const char *buff;
  std::string label;

  /* Raw files have names like:   u_blah-time_step-edge-z_level-normal.raw.0
     conceptually, the filename is split on dashes, with the first element
     giving a name of the variable, and the rest describing the layout of the file.
     here only a subset of possible layouts are supported.
     
     face: scalar data centered on 3D faces
     facenormal: saved as scalar data, but implied as a vector normal to the faces
     -uv means 2D vector data is being saved as opposed to scalar.
   */
  if ( regcomp(&cre, "([^-]+)(-time_step)?(-cell)?(-edge)?(-z_level)?(-normal)?(-uv)?.raw.0$", REG_EXTENDED)) {
    debug1 << "Couldn't compile pattern for finding raw data files" << endl;
    return;
  }

  ReadAndProcessDirectory( datadir,
                           save_file_name,
                           &filenames,
                           false );

  LocalMetadata lmd;
  
  for (int i=0; i < filenames.size(); i++ ){
    string basename = StringHelpers::Basename(filenames[i].c_str());
    debug1 << "Considering file " << basename << endl;
    
    buff = basename.c_str();

    if ( regexec(&cre, buff, 10, pm, 0) == 0 ) {
      debug1 << "This file looks promising: " << filenames[i] << endl;
      
      lmd.name = string( buff+pm[1].rm_so, pm[1].rm_eo - pm[1].rm_so);
      debug1 << "Label: " << lmd.name << endl;
      
      lmd.has_time = (pm[2].rm_so >= 0 );
      lmd.has_cell = (pm[3].rm_so >= 0 );
      lmd.has_edge = (pm[4].rm_so >= 0 );
      lmd.has_z_level = (pm[5].rm_so >= 0);
      // for simplicity, go ahead the vector field regardless
      lmd.is_normal = lmd.has_edge; // (pm[6].rm_so >= 0);
      if( pm[7].rm_so >= 0)
        lmd.n_components = 2; // 2-D velocity field
      else
        lmd.n_components = 1; // scalar

      // strip trailing .0:
      lmd.filename = filenames[i];
      lmd.filename.erase( lmd.filename.end()-2, lmd.filename.end());

      lmd.Add(md);
      // save it for easy retrieval during GetVar
      raw_vars[lmd.visit_label] = lmd;
      if ( lmd.is_normal )
        raw_vars[lmd.visit_normal_label] = lmd;

      debug1 << "And retrieved: " << raw_vars[lmd.visit_label].filename << endl;
    }
  }  
}

void LocalMetadata::Add(avtDatabaseMetaData *md)
{
  if ( has_cell ) {
    if ( n_components == 1 ) {
      avtScalarMetaData *smd = new avtScalarMetaData;
      if ( has_z_level ) {
        // MESH_3D
        smd->name = RAW "3D/" + name;
        smd->meshName = MESH_3D;
      } else {
        smd->name = RAW "2D/" + name;
        smd->meshName = MESH_2D;
      }
      visit_label = smd->name;
      smd->centering = AVT_ZONECENT;
      smd->hasUnits = false;
      md->Add(smd);
    } else { 
      // cell-centered vector data
      avtVectorMetaData *vmd = new avtVectorMetaData;
      if ( has_z_level ) {
        // MESH_3D
        vmd->name = RAW "3D/" + name;
        vmd->meshName = MESH_3D;
      } else {
        vmd->name = RAW "2D/" + name;
        vmd->meshName = MESH_2D;
      }

      visit_label = vmd->name;
      vmd->centering = AVT_ZONECENT;
      vmd->hasUnits = false;
      vmd->varDim = 3;
      md->Add(vmd);
    }
  }
  
  if ( has_edge ) {
    debug1 << "Got a face raw file" << endl;
    if ( has_z_level ) {
      avtScalarMetaData *smd = new avtScalarMetaData;
      smd->name = RAW "3D/" + name;
      visit_label = smd->name;
      smd->meshName = MESH_FACES;
      smd->centering = AVT_ZONECENT;
      smd->hasUnits = false;
      md->Add(smd);

      if ( is_normal ) {
        // make a vector version, whether we think it's a vector or not.
        avtVectorMetaData *vmd = new avtVectorMetaData;
        vmd->name = RAW "3D/vector_" + name;
        visit_normal_label = vmd->name;
        vmd->meshName = MESH_FACES;
        vmd->centering = AVT_ZONECENT;
        vmd->hasUnits = false;
        vmd->varDim = 3;
        md->Add(vmd);
      }
    } else {
      debug1 << "raw files: need to add support for 2D edge centered data" << endl;
    }
  }
}


void avtSuntansFileFormat::GetTimes(std::vector<double> &times)
{
  // in the suntans.dat file this is seconds.
  // here, use days to make it a bit friendlier
  int ntout = atoi( settings["ntout"].c_str() );
  double dt = atof( settings["dt"].c_str() ) / (24.0*3600.0);

  if ( available_timesteps == 0 ) {
    // put in a fake 0 timestep
    times.push_back(t0_days + starting_timestep*dt);
  } else {
    for(int i=0;i<available_timesteps;i++) {
      times.push_back(t0_days + starting_timestep*dt + ntout*dt*i);
    }
  }
}

void avtSuntansFileFormat::GetCycles(std::vector<int> &cycles)
{
  int ntout = atoi( settings["ntout"].c_str() );

  if ( available_timesteps == 0 ) {
    cycles.push_back(starting_timestep);
  } else {
    for(int i=0;i<available_timesteps;i++) {
      cycles.push_back(starting_timestep + i*ntout);
    }
  }
}


// ****************************************************************************
//  Method: avtSuntansFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Mon Oct 27 12:23:29 PDT 2008
//
// ****************************************************************************

vtkDataSet *
avtSuntansFileFormat::GetMesh(int timestate, int domain, const char *meshname)
{
  if ( strcmp(meshname,MESH_2D) == 0 ) 
    return subdomain(domain)->ReadSurfaceMesh();
  else if ( strcmp(meshname,MESH_DEPTH) == 0 ) 
    return ReadPointDepthMesh();
  else if ( strcmp(meshname,MESH_3D) == 0 ) 
    return subdomain(domain)->ReadFull3DMesh();
  else if ( strcmp(meshname,MESH_2D_PROF) == 0)
    return Read2DProfileMesh();
  else if ( strcmp(meshname,MESH_FACES) == 0 ) 
    return subdomain(domain)->ReadFaceMesh();
  else 
    return 0;
}


void
SunGrid::initialize_wet_cells(int timestate)
{
  int num_set=0;

  // already there - 
  if ( timestate == wet_cell_timestate ) 
    return;

  vtkDataArray *fs = GetVarFreesurface(timestate);

  wet_cell_index.resize( Nc, 0 );

  // iterate over the surface cell ids:
  for ( int surf_cell_id=0;
        surf_cell_id < Nc;
        surf_cell_id++) {
    double my_fs = fs->GetTuple1(surf_cell_id);

    // is this the first wet layer for this surface cell?
    // indexes into cell_divisions is 1 greater than the usual k in the
    // suntans code because cell_divisions includes cell_divisions[0]=0.0
    int k;
    for ( k=0 ; k < cells[surf_cell_id].Nk-1 ; k++) {
      // 2*dzmin should reflect DZMIN_SURFACE in phys.c
      if ( my_fs >= parent->cell_divisions[k+1] + 2*parent->dzmin )
        break;
    }
    wet_cell_index[surf_cell_id] = k;
  }

  fs->Delete();
  
  wet_cell_timestate = timestate;
}



vtkDataSet* avtSuntansFileFormat::Read2DProfileMesh() {
  double dt,x,y;
  int dummy;
  string profdata_fname = GetFilePath("ProfileDataFile");
    
  ifstream fp(profdata_fname.c_str(), ios::in | ios::binary);

  if ( !fp ) {
    debug1 << "failed to open " << profdata_fname << endl;
    return NULL;
  }

  debug1 << "Opened " << profdata_fname << " for profdata" << endl;
  debug1 << "Sizeof prof_total_points: " << sizeof(prof_total_points) << endl;

  if ( !fp.read((char*)&prof_total_points,4) ) {
    debug1 << "Issues reading prof_total_points" << endl;
  }

  fp.read((char*)&prof_numInterpPoints,4);
  fp.read((char*)&prof_NkmaxProfs,4);
  fp.read((char*)&dummy,4); /* nsteps */
  fp.read((char*)&prof_ntoutProfs,4); 
  fp.read((char*)&dt,8);

  /* skips:   dzz               all_indices           dataxy.dat */
  fp.seekg(28+8*prof_NkmaxProfs+4*prof_total_points + 2*8*prof_total_points );

  /* finally we can actually read the points */
  vtkPoints *points = vtkPoints::New();
  points->SetNumberOfPoints( prof_total_points * prof_numInterpPoints);
  float *pts = (float *) points->GetVoidPointer(0);

  /* the XY locations of the actual points */
  for( int i=0;i<prof_total_points * prof_numInterpPoints;i++) {
    fp.read((char*)&x,sizeof(x));
    pts[3*i] = (float)x;
  }
  for( int i=0;i<prof_total_points * prof_numInterpPoints;i++) {
    fp.read((char*)&y,sizeof(y));
    pts[3*i+1] = (float)y;
    pts[3*i+2] = 0.0; /* everybody is at 0 elevation */
  }

  fp.close();

  /* and then make a grid out of it */
  vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New();
  ugrid->SetPoints(points);
  points->Delete(); /* ??? */

  for(vtkIdType i=0;i<prof_total_points * prof_numInterpPoints;i++) {
    ugrid->InsertNextCell(VTK_VERTEX,1,&i);
  }
    
  return ugrid;
}  

void SunGrid::read_edgedata()
{
  string edgedata_fn = parent->GetFilePath("edgedata",domain);
  char buff[1024],*trav;
    
  ifstream edgedata_fp(edgedata_fn.c_str());
  double df,dg,n1,n2,xe,ye;
  int Nke,Nkc,grad1,grad2,gradf1,gradf2,mark,p1,p2,fld_count;

  edgedata data;

  // Figure out if there are 15 fields or 17:
  edgedata_fp.getline(buff,1024);
  fld_count = 1;
  strtok(buff," \t");
  while( trav = strtok( NULL," \t" ) )
    fld_count++;

  debug1 << "Found field count in edgedata " << fld_count << endl;
  
  edgedata_fp.seekg(0);
  
  while( edgedata_fp ) {
    // the old code:
    // 2.964496e+03 1.520637e+03 9.751834e-01 2.213984e-01 5.468434e+05 4.142464e+06 1 1 0 1 0 2 0 

    // the new code:
    // 520.216148   281.443688  -0.690743    -0.723101     37811.915665 179.667730   3 3 0 1 0 1 0 1 11
    
    // 15 values:
    // from the user guide:
    // df dg n1 n2 xe ye Nke Nkc grad{1,2} gradf{1,2} mark xi{1,2,3,4} eneigh{1,2,3,4}
    // an actual line:
    // df=26.620211 dg=7.609569 n1=-0.884785 n2=-0.466000
    // xe=22.793725 ye=11.776575
    // Nke=40 Nkc=40
    // grad1=0 grad2=3  - neighboring cells
    // gradf1=0 gradf2=2  - index of this edge in each cells face list
    // mark=0
    // p1=4 p2=6 
    edgedata_fp >> data.df >> data.dg >> data.n1 >> data.n2 >> data.xe >> data.ye;
    edgedata_fp >> data.Nke >> data.Nkc >> data.grad1 >> data.grad2 >> data.gradf1 >> data.gradf2;
    // p1 and p2 may not be there when older suntans code is used -
    edgedata_fp >> data.mark;
    if ( fld_count == 15 ) // just newer SUNTANS...
      edgedata_fp >> data.p1 >> data.p2;
    else 
      data.p1 = data.p2 = -999;
    
    if( !edgedata_fp ) {
      break;
    }
    edges.push_back(data);
  }
  Ne = edges.size();
  Ne_Nke = 0;
  for(int e=0;e<Ne;e++)
    Ne_Nke += edges[e].Nke;
  
  debug1 << "domain " << domain << ": Found " << Ne << " edges in edgedata" << endl;
}

void SunGrid::read_celldata()
{
  string celldata_fn = parent->GetFilePath("celldata",domain);
    
  ifstream celldata_fp(celldata_fn.c_str());
  

  celldata data;

  // old celldata lines:
  // 5.473636e+05 4.142627e+06 2.424136e+06 2.366088e+01 1 0 1 2 1 -1 40 -1 -1 -1 4.343652e+02 8.164241e+02 6.109901e+02
  // new celldata lines:
  // 37716.471100 79.752030    101881.987705  7.000000   3 0 1 2 1 10 -1 -1 -1 -1 138.176742   212.976206   79.752030
  
  while( celldata_fp ) {
    celldata_fp >> data.xv >> data.yv >> data.Ac >> data.dv >> data.Nk;
    celldata_fp >> data.edges[0] >> data.edges[1] >> data.edges[2];
    celldata_fp >> data.neighs[0] >> data.neighs[1] >> data.neighs[2];
    celldata_fp >> data.norms[0] >> data.norms[1] >> data.norms[2];
    celldata_fp >> data.defs[0] >> data.defs[1] >> data.defs[2];

    if( !celldata_fp ) {
      break;
    }

    data.ghost = 0;
    for(int f=0;f<3 && !data.ghost;f++) {
      int j = data.edges[f];
      if( edges[j].mark == 6 ) {
        data.ghost = 1;
        debug1 << "Got a ghost cell\n";
      }
    }

    cells.push_back(data);
  }
  Nc = cells.size();
  Nc_Nk = 0;
  for(int c=0;c<Nc;c++)
    Nc_Nk += cells[c].Nk;
  debug1 << "domain " << domain << ": Found " << cells.size() << " cells in celldata" << endl;
}


vtkDataSet* SunGrid::ReadSurfaceMesh() {
  if ( surf_mesh == NULL ) {
    // Read the ndims, nnodes, Nc, origin from file.
    vtkPoints *points = parent->ReadPoints();
       
    //
    // Create a vtkUnstructuredGrid to contain the point cells.
    //
    surf_mesh = vtkUnstructuredGrid::New();
    surf_mesh->SetPoints(points);
    points->Delete(); 
    
    /// Read the domain-specific cell file
    double vcenter_x,vcenter_y;
    int point_i[3]; // 0-based reference to points
    int nbr_i[3];
    vtkIdType verts[3];
   
    // not sure about this - there are default arguments,
    // so maybe it is smart enough to handle dynamic resizing...
    surf_mesh->Allocate();
       
    string cells_fname = parent->GetFilePath("cells",domain);
       
    ifstream cell_fp(cells_fname.c_str());
       
    while( cell_fp ) {
      cell_fp >> vcenter_x >> vcenter_y;
      cell_fp >> verts[0] >> verts[1] >> verts[2];
      cell_fp >> nbr_i[0] >> nbr_i[1] >> nbr_i[2];
      
      if( !cell_fp ) {
        break;
      }
      
      // Insert the cell into the mesh.
      surf_mesh->InsertNextCell(VTK_TRIANGLE, 3, verts);
    }

    // And try setting ghost zones:
    unsigned char realval=0, ghost=0; // not sure if this is right...
    avtGhostData::AddGhostZoneType(ghost, DUPLICATED_ZONE_INTERNAL_TO_PROBLEM);
    vtkUnsignedCharArray *ghostCells = vtkUnsignedCharArray::New();
    ghostCells->SetName("avtGhostZones");
    ghostCells->Allocate(Nc);
    for(int i=0;i<Nc;i++) {
      if ( cells[i].ghost==1 )
        ghostCells->InsertNextValue(ghost);
      else
        ghostCells->InsertNextValue(realval);
    }
    surf_mesh->GetCellData()->AddArray(ghostCells);
    surf_mesh->SetUpdateGhostLevel(0);
    ghostCells->Delete();
  }
  surf_mesh->Register(NULL);
  return surf_mesh;
}


vtkDataSet* SunGrid::ReadFull3DMesh() {
  if ( full_mesh == NULL ) {
    ////// Now basically extrude the surface mesh to prisms
    // bounded by the cell_divisions elevations 
   
    vtkUnstructuredGrid *surface = (vtkUnstructuredGrid *)ReadSurfaceMesh();
   
    // the new points 
    // copy the z=0 points from the flat surface, and then repeat
    // for each z-value 
    int n_surf_points = surface->GetNumberOfPoints();
   
    // number of points in each column:
    // not sure if this should be nkmax, nkmax+1
    // Nkmax >= 1, 
    // for Nkmax==1, that's one vertical cell, with a top presumably at 0
    // (really at freesurface...)
    // and a bottom at the depth.
   
    int n_per_column = parent->nkmax+1;
   
    vtkPoints *all_points = vtkPoints::New();
    all_points->SetNumberOfPoints( n_per_column*n_surf_points );
    float *ap_data = (float*)all_points->GetVoidPointer(0);
    double *surf_point;
    float *a_point;
   
    for(int surf_point_id=0;surf_point_id<n_surf_points;surf_point_id++) {
      surf_point = surface->GetPoint(surf_point_id);
      for(int k=0;k<n_per_column;k++){
        // pointer to the point being defined
        a_point = ap_data + 3*(surf_point_id+k*n_surf_points);
        
        a_point[0] = surf_point[0];
        a_point[1] = surf_point[1];
        a_point[2] = parent->cell_divisions[k];
      }
    }
   
    full_mesh = vtkUnstructuredGrid::New();
   
    // Copy the cell structure, extruding through depth
    vtkIdType surf_cell_type;
    vtkIdType *surf_cell_point_ids;
    
    vtkIdType new_cell_point_ids[6];
   
    // if we actually define all cells, the size could be determined
    // ahead of time for smarter allocation.  might end up culling
    // underground cells, though, so just leave it as dynamically
    // resized...
    
    // full_cell2valid provides a mapping of expected cell index to
    //  actual cell index;
    
    // settings['stairstep']=0 ->  The bottom of the bottom valid cell is defined
    //   by the voronoi center depth
    //                      =1 ->  Round to next z-level (deeper)
    // It's going to be a real pain to do partial depths, because it
    //  upsets the mapping of points to different depths (bottom points
    //   can't be reused, and the numbering gets all funky)
    
    //  later, when populating values, the invalid cells should get
    //    velocities of EMPTY which is currently defined in suntans.h
    //    to be 999999.
   
   
    // Fetch the depth values in order to evaluate the bottom cells
    vtkFloatArray *cell_depths =(vtkFloatArray *)GetVarBathymetry();
    float *bath_data = cell_depths->GetPointer(0);
       
    full_mesh->Allocate();
   
    int expected_cell_id=0;
    int real_cell_id=0;
     
    for(int surf_cell_id=0 ;
        surf_cell_id<Nc ;
        surf_cell_id++ ) {
      surface->GetCellPoints(surf_cell_id,
                             surf_cell_type,surf_cell_point_ids);
   
      int k; // index into vertical cells

      for(k=0;k< cells[surf_cell_id].Nk;k++) {
        /// The Visit manual shows this as 0-1-2 being one triangular
        // face with outward-facing normal, and 3-4-5 being the other
        // end with inward-facing normal (where the normal is defined
        // as outward on CCW ordered vertices)
        // if this really angers Visit, may have to test ordering here
        // and reverse top/bottom if vertices are in wrong order.
        
        // at some point we might add new bottom points to allow
        // for partial cell depths, but for now just do stair-stepping
        
        // the upper level:
        new_cell_point_ids[0] = k*n_surf_points + surf_cell_point_ids[0];
        new_cell_point_ids[1] = k*n_surf_points + surf_cell_point_ids[1];
        new_cell_point_ids[2] = k*n_surf_points + surf_cell_point_ids[2];
        
        // non-STAIRSTEPPING:
        // DEBUG: change to actually test for stairstepping later.
        if ( 1 && (parent->cell_divisions[k+1] < bath_data[surf_cell_id]) ) {
          // add in three new point to define the bottom:
          for(int vertex_i=0;vertex_i<3;vertex_i++) {
            // fetch the original point, then add it back but with a different z-value
            double point_buff[3];
            all_points->GetPoint( (k+1)*n_surf_points + surf_cell_point_ids[vertex_i],
                                  point_buff );
            point_buff[2] = bath_data[surf_cell_id];
            int new_bottom_point_id = all_points->InsertNextPoint(point_buff);
            
            new_cell_point_ids[3+vertex_i] = new_bottom_point_id;
          }
        } else {
          // the lower level:
          new_cell_point_ids[3] = (k+1)*n_surf_points + surf_cell_point_ids[0];
          new_cell_point_ids[4] = (k+1)*n_surf_points + surf_cell_point_ids[1];
          new_cell_point_ids[5] = (k+1)*n_surf_points + surf_cell_point_ids[2];
        }
        
        // Insert the cell into the mesh.
        full_mesh->InsertNextCell(VTK_WEDGE, 6, new_cell_point_ids);
   
        // update the mapping of cell ids:
        // the order of the data file is still a bit unclear, so hopefully
        // this is the same as in the data file...
        int expected_id = surf_cell_id + k*Nc;
   
        full_cell2valid[ expected_id ] = real_cell_id;
        
        real_cell_id++;
      }
    }
    
    // hopefully it's okay to set the points here, *after* defining the cells
    full_mesh->SetPoints(all_points);
    all_points->Delete();
    surface->Delete();
   
    n_3d_cells = full_mesh->GetNumberOfCells();
  }
  full_mesh->Register(NULL);
  return full_mesh;
}


vtkDataSet* SunGrid::ReadFaceMesh()
{
  if( face_mesh == NULL ) {
    // everything we need is in edgedata
    int nfaces = 0;
    for(int e=0;e<Ne;e++) {
      nfaces += edges[e].Nke;
    }
    debug1 << "Total faces: " << nfaces << endl;
    
    vtkPoints *points = vtkPoints::New();
    points->SetNumberOfPoints(nfaces);
    
    float *pts = (float *) points->GetVoidPointer(0);

    int f=0;
    for(int e=0;e<Ne;e++) {
      for(int k=0;k<edges[e].Nke;k++) {
        pts[3*f+0] = edges[e].xe;
        pts[3*f+1] = edges[e].ye;
        pts[3*f+2] = 0.5*(parent->cell_divisions[k] + parent->cell_divisions[k+1]);
        f++;
      }
    }

    face_mesh = vtkUnstructuredGrid::New();
    face_mesh->SetPoints(points);
    points->Delete();
    face_mesh->Allocate(nfaces);
    vtkIdType onevertex;
    for(f=0;f<nfaces;f++) {
      onevertex=f;
      face_mesh->InsertNextCell(VTK_VERTEX,1,&onevertex);
    }
  }
  face_mesh->Register(NULL);
  return face_mesh;
}


vtkDataSet* avtSuntansFileFormat::ReadPointDepthMesh() {
  vtkPoints *points = ReadDepthPoints();
  int n_depth_points = points->GetNumberOfPoints();
  vtkIdType onevertex;
    
  //
  // Create a vtkUnstructuredGrid to contain the point cells.
  //
  vtkUnstructuredGrid *ugrid = vtkUnstructuredGrid::New();
  ugrid->SetPoints(points);
  points->Delete();

  for(int i=0;i<n_depth_points;i++) {
    onevertex = i;
    ugrid->InsertNextCell(VTK_VERTEX,1,&onevertex);
  }
    
  return ugrid;
}

vtkPoints *avtSuntansFileFormat::ReadDepthPoints(void) {
  // avoid re-reading the file if possible
  if ( depths.size() == 0 ) {
    string depth_file = GetFilePath("depth");
    ifstream depth_fp(depth_file.c_str());
  
    float coord;
    
    while( depth_fp ) {
      depth_fp >> coord;
      if( !depth_fp )
        break;
      depths.push_back(coord);
    }
  }
  int n_depth_points = depths.size()/3;
  
  vtkPoints *points = vtkPoints::New();
  points->SetNumberOfPoints(n_depth_points);
  float *pts = (float *) points->GetVoidPointer(0);

  for(int i=0;i<depths.size()/3;i++) {
    pts[3*i]   = depths[3*i];
    pts[3*i+1] = depths[3*i+1];
    pts[3*i+2] = 0.0; // maybe it doesn't matter if we assign z or not
  }
  return points;
}

vtkPoints *avtSuntansFileFormat::ReadPoints(void) {
  if ( points == NULL ) {
    std::string points_fname;
    points_fname = GetFilePath("points");
    
    ifstream points_fp(points_fname.c_str());
    
    std::vector<double> coords;
    double coord;
    
    while( points_fp.good() ) {
      points_fp >> coord;
      coords.push_back(coord);
    }
    
    debug1 << "Read " << coords.size() << " individual coordinates" << endl;
    
    int nnodes = coords.size()/3;
    
    //
    // Create the vtkPoints object and copy points into it.
    //
    points = vtkPoints::New();
    points->SetNumberOfPoints(nnodes);
    float *pts = (float *) points->GetVoidPointer(0);
    
    for(int i=0;i<nnodes*3;i++) {
      pts[i] = coords[i];
    }
  }

  points->Register(NULL);
  return points;
}


// ****************************************************************************
//  Method: avtSuntansFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Mon Oct 27 12:23:29 PDT 2008
//
// ****************************************************************************

vtkDataArray *SunGrid::GetVarFreesurface(int timestate)
{
  vtkDoubleArray *rv  = vtkDoubleArray::New();
  rv->SetNumberOfTuples(Nc);

  double *data = rv->GetPointer(0);

  std::string fs_file = parent->GetFilePath("FreeSurfaceFile",domain);
    
  ifstream fs_fp(fs_file.c_str());

  // each timestate
  long int offset = timestate*Nc*sizeof(double);
    
  fs_fp.seekg(offset);
  fs_fp.read((char*)data,Nc*sizeof(double));
    
  return rv;
}

vtkDataArray *SunGrid::GetVarNk()
{
  vtkFloatArray *rv  = vtkFloatArray::New();
  rv->SetNumberOfTuples(Nc);

  float *data = rv->GetPointer(0);

  for(int i=0;i<Nc;i++){
    data[i] = cells[i].Nk;
  }
  return rv;
}

vtkDataArray *SunGrid::GetVarStoreFreesurface()
{
  return GetVarStoreFreesurface( parent->GetFilePath("StoreFile",domain) );
}

vtkDataArray *SunGrid::GetVarCrashFreesurface()
{
  return GetVarStoreFreesurface( parent->GetFilePath("CrashFile",domain) );
}


vtkDataArray *SunGrid::GetVarStoreFreesurface(string fs_file)
{
  vtkDoubleArray *rv  = vtkDoubleArray::New();
  
  cout << "Number of surface cells: " << Nc << endl;
  rv->SetNumberOfTuples(Nc);
  
  double *data = rv->GetPointer(0);

  ifstream fs_fp(fs_file.c_str());

  // skip timestep int
  int offset = sizeof(int);
    
  fs_fp.seekg(offset);
  fs_fp.read((char*)data,Nc*sizeof(double));
    
  return rv;
}

vtkDataArray *SunGrid::GetVarStoreNormVelocity()
{
  return GetVarStoreNormVelocity( parent->GetFilePath("StoreFile",domain) );
}

vtkDataArray *SunGrid::GetVarCrashNormVelocity()
{
  return GetVarStoreNormVelocity( parent->GetFilePath("CrashFile",domain) );
}


vtkDataArray *SunGrid::GetVarStoreNormVelocity(string fs_file)
{
  // First, figure out how far into the file to seek
  debug1 << "domain " << domain << ": Nc=" << Nc << "  Ne_Nke=" << Ne_Nke
         << " Nc_Nk=" << Nc_Nk << endl;
    
  long int u_offset= 4 + // timestep
    8*(Nc         // freesurface
       +Ne_Nke    // ab_hor_moment
       +Nc_Nk     // ab_vert_moment
       +Nc_Nk     // ab_salinity
       +Nc_Nk     // ab_temperature
       +Nc_Nk     // ab_turb_q
       +Nc_Nk     // ab_turb_l
       +Nc_Nk     // turb_q
       +Nc_Nk     // turb_l
       +Nc_Nk     // nu_T
       +Nc_Nk);   // K_T


  vtkDoubleArray *rv = vtkDoubleArray::New();

  rv->SetNumberOfComponents(1);
  rv->SetNumberOfTuples(Ne_Nke);
  
  double *data = rv->GetPointer(0);


  debug1 << "offset into " << fs_file << " for u velocity="<< u_offset << endl;

  ifstream fs_fp(fs_file.c_str());

  fs_fp.seekg(u_offset);
  fs_fp.read((char*)data,Ne_Nke*sizeof(double));
  fs_fp.close();
    
  return rv;
}

vtkDataArray *SunGrid::GetVarStoreNormWVelocity()
{
  return GetVarStoreNormWVelocity( parent->GetFilePath("StoreFile",domain) );
}

vtkDataArray *SunGrid::GetVarCrashNormWVelocity()
{
  return GetVarStoreNormWVelocity( parent->GetFilePath("CrashFile",domain) );
}

vtkDataArray *SunGrid::GetVarStoreNormWVelocity(string fs_file)
{
  long int w_offset= 4 + // timestep
    8*(Nc         // freesurface
       +Ne_Nke    // ab_hor_moment
       +Nc_Nk     // ab_vert_moment
       +Nc_Nk     // ab_salinity
       +Nc_Nk     // ab_temperature
       +Nc_Nk     // ab_turb_q
       +Nc_Nk     // ab_turb_l
       +Nc_Nk     // turb_q
       +Nc_Nk     // turb_l
       +Nc_Nk     // nu_T
       +Nc_Nk     // K_T
       +Ne_Nke);    // horizontal face velocities

  vtkDoubleArray *rv = vtkDoubleArray::New();

  rv->SetNumberOfComponents(1);
  // cheating - should be Nc_(Nk+1)
  rv->SetNumberOfTuples(Nc_Nk);
  
  double *data = rv->GetPointer(0);

  debug1 << "offset into " << fs_file << " for w velocity="<< w_offset << endl;

  ifstream fs_fp(fs_file.c_str());

  fs_fp.seekg(w_offset);

  double dummy;
  for(int i=0;i<Nc;i++) {
    // fs_fp.read((char*)data,Ne_Nke*sizeof(double));
    fs_fp.read( (char*)data,cells[i].Nk * sizeof(double) );
    // eat the extra w value:
    fs_fp.read( (char*)(&dummy),sizeof(double)); 
    // move data to point to the top of the next watercolumn
    data = data + cells[i].Nk;
  }
  fs_fp.close();
    
  return rv;
}

// HERE
vtkDataArray *SunGrid::GetVarCrashSalinity() 
{
  return GetVarStoreSalinity( parent->GetFilePath("CrashFile",domain) );
}

vtkDataArray *SunGrid::GetVarStoreSalinity() 
{
  return GetVarStoreSalinity( parent->GetFilePath("StoreFile",domain) );
}


vtkDataArray *SunGrid::GetVarStoreSalinity(string fs_file)
{
  long int s_offset= 4 + // timestep
    8*(Nc         // freesurface
       +Ne_Nke    // ab_hor_moment
       +Nc_Nk     // ab_vert_moment
       +Nc_Nk     // ab_salinity
       +Nc_Nk     // ab_temperature
       +Nc_Nk     // ab_turb_q
       +Nc_Nk     // ab_turb_l
       +Nc_Nk     // turb_q
       +Nc_Nk     // turb_l
       +Nc_Nk     // nu_T
       +Nc_Nk     // K_T
       +Ne_Nke    // horizontal face velocities
       +(Nc_Nk + Nc) // vertical velocity
       +Nc_Nk);    // nonhydrostatic pressure
  
  vtkDoubleArray *rv = vtkDoubleArray::New();

  rv->SetNumberOfComponents(1);
  rv->SetNumberOfTuples(Nc_Nk);
  
  double *data = rv->GetPointer(0);

  debug1 << "offset into " << fs_file << " for salinity="<< s_offset << endl;

  ifstream fs_fp(fs_file.c_str());

  fs_fp.seekg(s_offset);

  double dummy;
  for(int i=0;i<Nc;i++) {
    // fs_fp.read((char*)data,Ne_Nke*sizeof(double));
    fs_fp.read( (char*)data,cells[i].Nk * sizeof(double) );
    // move data to point to the top of the next watercolumn
    data = data + cells[i].Nk;
  }
  fs_fp.close();
    
  return rv;
}



vtkDataArray *SunGrid::GetVectorVarCrashVelocity()
{
  return project_to_facenormal( GetVarCrashNormVelocity() );
}

vtkDataArray *SunGrid::GetVectorVarStoreVelocity()
{
  return project_to_facenormal( GetVarStoreNormVelocity() );
}


vtkDataArray *SunGrid::GetVectorVarFaceNormals()
{
  vtkFloatArray *rv = vtkFloatArray::New();

  rv->SetNumberOfComponents(1);
  rv->SetNumberOfTuples(Ne_Nke);
  
  float *data = rv->GetPointer(0);
  for(int i=0;i<Ne_Nke;i++){
    data[i] = 1.0;
  }

  return project_to_facenormal( rv );
}


vtkDataArray *SunGrid::GetVectorVarCrashWVelocity() {
  return project_w_vectors( GetVarCrashNormWVelocity() );
}

vtkDataArray *SunGrid::GetVectorVarStoreWVelocity() {
  return project_w_vectors( GetVarStoreNormWVelocity() );
}


vtkDataArray *SunGrid::project_w_vectors(vtkDataArray *norm) {
  vtkFloatArray *rv = vtkFloatArray::New();
  rv->SetNumberOfComponents(3);
  rv->SetNumberOfTuples( Nc_Nk );

  float *data = rv->GetPointer(0);

  int f=0;
  for( int i=0;i<Nc;i++ )
    for( int k=0;k<cells[i].Nk;k++) {
      double w = norm->GetTuple1(f);
      data[3*f+0] = 0;
      data[3*f+1] = 0;
      data[3*f+2] = (float)w;
      f++;
    }
  norm->Delete();
  return rv;
}


// it is assumed that we 'own' norm - so it is consumed and
// the resulting array is 'owned' by the caller.
vtkDataArray *SunGrid::project_to_facenormal(vtkDataArray *norm)
{
  vtkFloatArray *rv = vtkFloatArray::New();
  rv->SetNumberOfComponents(3);
  if ( norm->GetNumberOfTuples() != Ne_Nke ){
    debug1 << "Bad number of tuples for projecting to face normals " << Ne_Nke << ","
           << norm->GetNumberOfTuples() << endl;
  }
  rv->SetNumberOfTuples( Ne_Nke );
  
  float *data = rv->GetPointer(0);

  int f=0;
  for( int e=0;e<Ne;e++ )
    for( int k=0;k<edges[e].Nke;k++) {
      double u = norm->GetTuple1(f);
      data[3*f+0] = u*edges[e].n1;
      data[3*f+1] = u*edges[e].n2;
      data[3*f+2] = 0;
      f++;
    }
  norm->Delete();
  return rv;
}


vtkDataArray *SunGrid::GetVarBathymetry()
{
  if ( bathymetry == NULL ) {
    bathymetry = vtkFloatArray::New();
    bathymetry->SetNumberOfTuples(Nc);
   
    float *bath_data = bathymetry->GetPointer(0);

    for(int i=0;i<Nc;i++) {
      bath_data[i] = -cells[i].dv;
    }
  }
  bathymetry->Register(NULL);
  return bathymetry;
}

vtkDataArray *SunGrid::GetVar3DScalar(int timestate,const char *varname)
{
  /* temp, salinity and nu_t_vert are handled the same, the only difference is which file is read */
  vtkFloatArray *rv = vtkFloatArray::New();
    
  rv->SetNumberOfComponents(1);
  rv->SetNumberOfTuples(n_3d_cells);
  float *scal_data = rv->GetPointer(0);
    
  string scal_fname;
  if (strcmp(varname,"salinity") == 0 )
    scal_fname = parent->GetFilePath("SalinityFile",domain);
  else if (strcmp(varname,"temperature") == 0 )
    scal_fname = parent->GetFilePath("TemperatureFile",domain);
  else 
    scal_fname = parent->GetFilePath("EddyViscosityFile",domain);

  ifstream scal_fp(scal_fname.c_str());

  // each time step has nkmax*Nc cells,
  // and each cell has 1 salinity value
  // with each component taking up 8 bytes:
  scal_fp.seekg( timestate*Nc*parent->nkmax*sizeof(double) );
    
  // read one z-level at a time
  double *one_slice = new double[Nc];

  for (int k=0;k<parent->nkmax;k++) {
    scal_fp.read((char*)one_slice,Nc*sizeof(double));

    // iterate over the surface cell ids:
    for ( int surf_cell_id=0;surf_cell_id<Nc;surf_cell_id++) {
      // some versions of the code output 0 for non-existent cells, so
      // to be safe check both for EMPTY and for an entry in full_cell2valid[]
      int expected_id = surf_cell_id + k*Nc;

      if( full_cell2valid.count(expected_id) >= 1 ) {
        int real_id = full_cell2valid[expected_id];
        scal_data[real_id] = one_slice[surf_cell_id];
      }
    }
  }
  delete[] one_slice;
  return rv;
}

vtkDataArray *SunGrid::GetVarSurfaceScalar(int timestate, const char *varname)
{
  /* temp, salinity and nu_t_vert are handled the same, the only difference is which file is read */
  vtkFloatArray *rv = vtkFloatArray::New();
  
  rv->SetNumberOfComponents(1);
  rv->SetNumberOfTuples(Nc);
  float *scal_data = rv->GetPointer(0);

  string scal_fname;
  if (strcmp(varname,"salinity_surface") == 0 )
    scal_fname = parent->GetFilePath("SalinityFile",domain);
  else if (strcmp(varname,"temperature_surface") == 0 )
    scal_fname = parent->GetFilePath("TemperatureFile",domain);
  else /* nu_t_vert */
    scal_fname = parent->GetFilePath("EddyViscosityFile",domain);

  ifstream scal_fp(scal_fname.c_str());
  
  // each time step has nkmax*Nc cells,
  // and each cell has 1 salinity value
  // with each component taking up 8 bytes:
  long int offset =  timestate*parent->nkmax*Nc*sizeof(double);

  scal_fp.seekg(offset);
  
  // read one z-level at a time
  double *one_slice = new double[Nc];

  debug1 << "Calling initialize_wet_cells" << endl;
  initialize_wet_cells(timestate);
  debug1 << "Back from initialize_wet_cells" << endl;
  
  // this could be made more efficient by keeping track of the
  // highest and lowest wet cell index, and only reading those slices.
  for (int k=0;k<parent->nkmax;k++) {
    offset = scal_fp.tellg();

    scal_fp.read((char*)one_slice,Nc*sizeof(double));

    if ( !scal_fp) {
      debug1 << "Hit the end of file while looking for surface scalar values" << endl;
      for(int surf_cell_id=0;surf_cell_id<Nc;surf_cell_id++) {
        scal_data[surf_cell_id] = -1.0;
      }
      delete[] one_slice;
      return rv;
    } else {
      // iterate over the surface cell ids:
      for ( int surf_cell_id=0;surf_cell_id<Nc;surf_cell_id++) {
        // initialize to known bad value:
        if ( k== 0 )
          scal_data[surf_cell_id] = 37.0;
        
        if ( wet_cell_index[surf_cell_id] == k ) {
          scal_data[surf_cell_id] = one_slice[surf_cell_id];
        }

        if( scal_data[surf_cell_id] <-100 || scal_data[surf_cell_id]> 100) {
          debug1 << "WHOA: domain: " << domain <<  " i="<<surf_cell_id << " wet_cell_index="<<wet_cell_index[surf_cell_id] << 
            " value " << scal_data[surf_cell_id] << endl;
        }
      }
    }
  }
  
  delete[] one_slice;
  return rv;
}

vtkDataArray *SunGrid::GetVarBedScalar(int timestate, const char *varname)
{
  debug1 << "top of GetVarBedScalar Nc=" << Nc << endl;
  
  /* temp, salinity and nu_t_vert are handled the same, the only difference is which file is read */
  vtkFloatArray *rv = vtkFloatArray::New();
  
  rv->SetNumberOfComponents(1);
  rv->SetNumberOfTuples(Nc);
  float *scal_data = rv->GetPointer(0);

  string scal_fname;
  if (strcmp(varname,"salinity_bed") == 0 )
    scal_fname = parent->GetFilePath("SalinityFile",domain);
  else if (strcmp(varname,"temperature_bed") == 0 )
    scal_fname = parent->GetFilePath("TemperatureFile",domain);
  else /* nu_t_vert */
    scal_fname = parent->GetFilePath("EddyViscosityFile",domain);

  ifstream scal_fp(scal_fname.c_str());
  
  // each time step has nkmax*Nc cells,
  // and each cell has 1 salinity value
  // with each component taking up 8 bytes:
  long int offset =  timestate*parent->nkmax*Nc*sizeof(double);

  scal_fp.seekg(offset);
  
  // read one z-level at a time
  double *one_slice = new double[Nc];

  initialize_wet_cells(timestate);
  
  // this could be made more efficient by keeping track of the
  // highest and lowest wet cell index, and only reading those slices.
  for (int k=0;k<parent->nkmax;k++) {
    offset = scal_fp.tellg();

    scal_fp.read((char*)one_slice,Nc*sizeof(double));
      
    // iterate over the surface cell ids:
    for ( int surf_cell_id=0;surf_cell_id<Nc;surf_cell_id++) {
      // initialize to known bad value:
      if ( k== 0 )
        scal_data[surf_cell_id] = 0.0;
        
      if ( k + 1 == cells[surf_cell_id].Nk ) {
        scal_data[surf_cell_id] = one_slice[surf_cell_id];
      }
    }
  }
  
  delete[] one_slice;
  debug1 << "leaving GetVarBedScalar" << endl;
  return rv;
}



vtkDataArray *SunGrid::GetVarRaw(int timestate, const char *varname)
{
  // NB: this is a stack copy - modifications will not be saved!
  LocalMetadata lmd = parent->raw_vars[varname];
  std::ostringstream extended;
  extended << lmd.filename << "." << domain; 

  // RAW FILES
  if ( !lmd.has_z_level && lmd.has_cell ) {
    ifstream fs_fp(extended.str().c_str());

    // read it just like bathymetry, but no timesteps
    vtkDoubleArray *rv  = vtkDoubleArray::New();

    // if the name implies it has time, seek to the correct frame:
    if ( lmd.has_time ) 
      fs_fp.seekg(timestate * Nc * lmd.n_components * sizeof(double));

    if ( lmd.n_components == 1 ) {
      rv->SetNumberOfComponents(1);
      rv->SetNumberOfTuples(Nc);
      double *data = rv->GetPointer(0);
  
      // if the name implies it has time, seek to the correct frame:
      if ( lmd.has_time ) 
        fs_fp.seekg(timestate * Nc * sizeof(double));
  
      fs_fp.read((char*)data,Nc*sizeof(double));
    } else {
      // vector data --
      // always return 3 components, even if the data really has 2.
      rv->SetNumberOfComponents(3);
      rv->SetNumberOfTuples(Nc);
      double *data = rv->GetPointer(0);

      // even if the file has only 2 components, read it in one go.
      // for a bit of extra speed.
      fs_fp.read((char*)data,Nc*lmd.n_components*sizeof(double));
      
      if( lmd.n_components == 2 ) {
        // have to remap those values:
        for(int i=Nc-1;i>0;i--) {
          data[3*i] = data[2*i];
          data[3*i+1] = data[2*i+1];
          data[3*i+2] = 0.0; // no z component
        }
        data[2] = 0.0;
      } 
    }
    debug1 << "Returning data for " << lmd.filename << endl;
    return rv;
  } else if ( lmd.has_z_level && lmd.has_cell ) {
    // this is like salinity, but only above-ground cells are in the output
    // file - which matches the layout of the full 3D mesh, so we can read
    // data in one pass.
    vtkDoubleArray *rv  = vtkDoubleArray::New();
    rv->SetNumberOfComponents(1);
    rv->SetNumberOfTuples(n_3d_cells);

    double *data = rv->GetPointer(0);

    debug1 << "SUN: Opening 3D raw data file '" << extended.str() << "'" << endl;

    ifstream fs_fp(extended.str().c_str());

    if ( lmd.has_time ) 
      fs_fp.seekg( timestate * sizeof(double) * n_3d_cells );

    fs_fp.read((char*)data, n_3d_cells * sizeof(double) );
    
    return rv;
  } else if ( lmd.has_edge && lmd.has_z_level ) {
    debug1 << "SUN: okay - it's a scalar face file" << endl;
    
    // For face normal, we read Ne_Nke values, then hand it off to be
    // projected to normals.
    vtkDoubleArray *rv  = vtkDoubleArray::New();
    rv->SetNumberOfComponents(1);
    rv->SetNumberOfTuples(Ne_Nke);
    
    double *data = rv->GetPointer(0);
  
    ifstream fs_fp(extended.str().c_str());

    if ( lmd.has_time ) 
      fs_fp.seekg(timestate * Ne_Nke * sizeof(double));
  
    fs_fp.read((char*)data,Ne_Nke*sizeof(double));

    return rv;
  } else {
    debug1 << "Not ready for 3D raw variables" << endl;
    return 0;
  }
}

vtkDataArray *SunGrid::GetVectorVarRaw(int timestate,const char *varname)
{
  LocalMetadata lmd = parent->raw_vars[varname];

  // RAW FILES
  if ( lmd.is_normal ) {
    return project_to_facenormal( GetVarRaw(timestate,lmd.visit_label.c_str() ) );
  } else {
    return GetVarRaw(timestate,varname);
  }
  return NULL;
}


vtkDataArray *
avtSuntansFileFormat::GetVar(int timestate, int domain, const char *varname)
{
  debug1 << "avtsuntans: request for variable " << varname << endl;

  if ( strcmp(varname,"freesurface") == 0 ) 
    return subdomain(domain)->GetVarFreesurface(timestate);

  if ( strcmp(varname,"Nk") == 0 ) 
    return subdomain(domain)->GetVarNk();

  if ( strcmp(varname,"prof_freesurface") == 0 ) {
    vtkDoubleArray *rv  = vtkDoubleArray::New();
    rv->SetNumberOfTuples(prof_total_points * prof_numInterpPoints);

    double *data = rv->GetPointer(0);

    std::string fs_file = GetFilePath("FreeSurfaceFile") + ".prof";
    
    ifstream fs_fp(fs_file.c_str());

    // each timestate
    long int offset = timestate*(prof_total_points*prof_numInterpPoints)*sizeof(double);
    
    fs_fp.seekg(offset);
    fs_fp.read((char*)data,(prof_total_points*prof_numInterpPoints)*sizeof(double));
    
    return rv;
  }

  // Crash file
  if ( strcmp(varname,"crash/freesurface") == 0 ) 
    return subdomain(domain)->GetVarCrashFreesurface();

  if ( strcmp(varname,"crash/salinity") == 0 )
    return subdomain(domain)->GetVarCrashSalinity();

  if ( strcmp(varname,"crash/norm_velocity") == 0 )
    return subdomain(domain)->GetVarCrashNormVelocity();

  // Store file
  if ( strcmp(varname,"store/freesurface") == 0 ) 
    return subdomain(domain)->GetVarStoreFreesurface();

  if ( strcmp(varname,"store/salinity") == 0 )
    return subdomain(domain)->GetVarStoreSalinity();

  if ( strcmp(varname,"store/norm_velocity") == 0 )
    return subdomain(domain)->GetVarStoreNormVelocity();
  

  ///
  if ( strcmp(varname,"bathymetry") == 0 ) 
    return subdomain(domain)->GetVarBathymetry();
  
  if ( strcmp(varname,"point_depth") == 0 ) {
    vtkFloatArray *rv  = vtkFloatArray::New();
    rv->SetNumberOfTuples(depths.size()/3);
    float *depth_data = rv->GetPointer(0);

    for(int i=0;i<depths.size()/3;i++) 
      depth_data[i] = depths[3*i+2];
    
    return rv;
  }
  
  if ( strcmp(varname,"salinity") == 0 ||
       strcmp(varname,"temperature") == 0 ||
       strcmp(varname,"nu_t_vert") == 0 ) 
    return subdomain(domain)->GetVar3DScalar(timestate,varname);

  if ( strcmp(varname,"salinity_surface") == 0    ||
       strcmp(varname,"temperature_surface") == 0 ||
       strcmp(varname,"nu_t_vert_surface") == 0    ) 
    return subdomain(domain)->GetVarSurfaceScalar(timestate,varname);

  if ( strcmp(varname,"salinity_bed") == 0    ||
       strcmp(varname,"temperature_bed") == 0 ||
       strcmp(varname,"nu_t_vert_bed") == 0    ) 
    return subdomain(domain)->GetVarBedScalar(timestate,varname);
  
  if (strncmp(varname,"raw/",4) == 0 ) 
    return subdomain(domain)->GetVarRaw(timestate,varname);

  debug1 << "avtsuntans GetVar: failed to find a match for variable " << varname << endl;
  return 0;
}


// ****************************************************************************
//  Method: avtSuntansFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: rusty -- generated by xml2avt
//  Creation:   Mon Oct 27 12:23:29 PDT 2008
//
// ****************************************************************************

vtkDataArray *SunGrid::GetVectorVarVelocity(int timestate)
{
  vtkFloatArray *rv = vtkFloatArray::New();
  rv->SetNumberOfComponents(3);
  rv->SetNumberOfTuples(n_3d_cells);

  string vel_fname = parent->GetFilePath("HorizontalVelocityFile",domain);
  ifstream vel_fp(vel_fname.c_str());

  // each time step has nkmax*Nc cells,
  // and each cell has 3 velocity components,
  // with each component taking up 8 bytes:
  vel_fp.seekg( timestate*Nc*parent->nkmax*3*sizeof(double) );
    

  // read one slice at a time, which is first Nc of
  // x-components, then Nc of y-components, and finally
  // Nc of z-components;

  double *one_slice = new double[3*Nc];
  float one_entry[3];
  float zero_entry[3]={0,0,0};

  for (int k=0;k<parent->nkmax;k++) {
    vel_fp.read((char*)one_slice,3*Nc*sizeof(double));

    // iterate over the surface cell ids:
    for ( int surf_cell_id=0;surf_cell_id<Nc;surf_cell_id++) {
      one_entry[0] = one_slice[surf_cell_id];
      one_entry[1] = one_slice[Nc+surf_cell_id];
      one_entry[2] = one_slice[2*Nc+surf_cell_id];

      // some versions of the code output 0 for non-existent cells, so
      // to be safe check both for EMPTY and for an entry in full_cell2valid[]
      int expected_id = surf_cell_id + k*Nc;
      if( full_cell2valid.count(expected_id) >= 1 ) {
        int real_id = full_cell2valid[expected_id];
        if ( one_entry[0] == EMPTY ) {
          // just in case a cell that we promised to Visit somehow gets
          // returned to us with EMPTY data (maybe it dried out?)
          rv->SetTuple(real_id, zero_entry);
        } else {
          rv->SetTuple(real_id, one_entry);
        }
      }
    }
  }
  delete[] one_slice;
  return rv;
}


vtkDataArray *SunGrid::GetVectorVarVelocitySurface(int timestate)
{
  debug1 << "Reading surface velocities" << endl;
    
  initialize_wet_cells(timestate);

  vtkFloatArray *rv = vtkFloatArray::New();

  rv->SetNumberOfComponents(3);
  rv->SetNumberOfTuples(Nc);

  string vel_fname = parent->GetFilePath("HorizontalVelocityFile",domain);
  debug1 << "Opening" << vel_fname << endl;
  ifstream vel_fp(vel_fname.c_str());

  // each time step has nkmax*Nc cells,
  // and each cell has 3 velocity components,
  // with each component taking up 8 bytes:
  int offset = timestate*Nc*parent->nkmax*3*sizeof(double);
  debug1 << "and seeked (sought?) to " << offset << endl;

  vel_fp.seekg( offset );

  // read one slice at a time, which is first Nc of
  // x-components, then Nc of y-components, and finally
  // Nc of z-components;

  double *one_slice = new double[3*Nc];
  float one_entry[3];
  float zero_entry[3]={0,0,0};
  
  int num_set = 0;
  for ( int k=0;k < parent->nkmax ; k++) {
    vel_fp.read((char*)one_slice,3*Nc*sizeof(double));

    // iterate over the surface cell ids:
    for ( int surf_cell_id=0;surf_cell_id<Nc;surf_cell_id++) {
      if ( k == wet_cell_index[surf_cell_id] ) {
        one_entry[0] = one_slice[surf_cell_id];
        one_entry[1] = one_slice[Nc+surf_cell_id];
        one_entry[2] = one_slice[2*Nc+surf_cell_id];
  
        rv->SetTuple(surf_cell_id, one_entry);
      }
    }
  }  
  delete[] one_slice;

  return rv;
}

vtkDataArray *
avtSuntansFileFormat::GetVectorVar(int timestate, int domain,const char *varname)
{
  if ( strcmp(varname,"velocity_3d") == 0 ) {
    return subdomain(domain)->GetVectorVarVelocity(timestate);
    
  } else if ( strcmp(varname,"velocity_surface") == 0 ) {
    return subdomain(domain)->GetVectorVarVelocitySurface(timestate);
  } else if ( strcmp(varname,"face_normals") == 0 ) {
    return subdomain(domain)->GetVectorVarFaceNormals();
  } else if ( strcmp(varname,"crash/velocity") == 0 ) {
    return subdomain(domain)->GetVectorVarCrashVelocity();
  } else if ( strcmp(varname,"crash/w_velocity") == 0 ) {
    return subdomain(domain)->GetVectorVarCrashWVelocity();
  } else if ( strcmp(varname,"store/velocity") == 0 ) {
    return subdomain(domain)->GetVectorVarStoreVelocity();
  } else if ( strcmp(varname,"store/w_velocity") == 0 ) {
    return subdomain(domain)->GetVectorVarStoreWVelocity();
  } else if (strncmp(varname,"raw/",4) == 0 ) {
    vtkDataArray *val = subdomain(domain)->GetVectorVarRaw(timestate,varname);
    debug1 << "GetVectorVar is retuning" << endl;
    return val;
  } else
    return 0;
}
